<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js 正交相机示例</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        color: #333;
        font-size: 18px;
        font-family: sans-serif;
      }
    </style>
  </head>
  <body>
    <div id="info">正交相机 (Orthographic Camera) - 远近一样大</div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // 1. 基础设置
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 2. 创建正交相机
      const aspect = window.innerWidth / window.innerHeight;
      const frustumSize = 5; // 视景体高度
      const camera = new THREE.OrthographicCamera(
        (frustumSize * aspect) / -2, // left
        (frustumSize * aspect) / 2, // right
        frustumSize / 2, // top
        frustumSize / -2, // bottom
        0.1,
        1000
      );
      camera.position.set(2, 1, 5); // 设置相机位置
      camera.lookAt(0, 0, 0); // 相机望向原点

      // 3. 添加物体以观察正交效果
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const materialNear = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // 红色
      const materialFar = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // 蓝色

      // 创建近处的立方体 (红色)
      const cubeNear = new THREE.Mesh(geometry, materialNear);
      cubeNear.position.set(0.75, 0.5, 0);
      scene.add(cubeNear);

      // 创建远处的立方体 (蓝色)
      const cubeFar = new THREE.Mesh(geometry, materialFar);
      cubeFar.position.set(-0.75, 0.5, -3);
      scene.add(cubeFar);

      // 添加一个地面网格辅助观察
      const gridHelper = new THREE.GridHelper(10, 10);
      scene.add(gridHelper);

      // 4. 添加轨道控制器以便交互
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // 5. 渲染循环
      function animate() {
        requestAnimationFrame(animate);
        controls.update(); // 更新控制器
        renderer.render(scene, camera);
      }

      // 6. 窗口自适应
      window.addEventListener("resize", () => {
        const aspect = window.innerWidth / window.innerHeight;
        camera.left = (frustumSize * aspect) / -2;
        camera.right = (frustumSize * aspect) / 2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
